{"version":3,"names":[],"mappings":"","sources":["jquery.aria.js"],"sourcesContent":["/*! jquery-aria (https://github.com/Skateside/jquery-aria#readme) - v0.7.0a - MIT license - 2017-4-1 */\n(function ($) {\n    \"use strict\";\n\n// Source: /src/doc/file.js\n/**\n * @file\n * This is a jQuery plugin that adds methods for manipulating WAI-ARIA\n * attributes. Unlike other plugins that do similar things, this plugin has been\n * designed to match jQuery's style making it much easier to pick up. The plugin\n * includes:\n * <br><br>\n * <strong>Getting and Setting WAI-ARIA Attributes</strong>\n * <br>[jQuery#aria]{@link external:jQuery#aria} for getting and setting\n * WAI-ARIA attributes.\n * <br>[jQuery#ariaRef]{@link external:jQuery#ariaRef} for getting and setting\n * references to other elements.\n * <br>[jQuery#ariaState]{@link external:jQuery#ariaState} for getting and\n * setting states.\n * <br><br>\n * <strong>Removing WAI-ARIA Attributes</strong>\n * <br>[jQuery#removeAria]{@link external:jQuery#removeAria} for removing\n * WAI-ARIA attributes (aliased as\n * [jQuery#removeAriaRef]{@link external:jQuery#removeAriaRef} and\n * [jQuery#removeAriaState]{@link external:jQuery#removeAriaState}).\n * <br><br>\n * <strong>Adjusting WAI-ARIA Attribute Manipulation</strong>\n * <br>[jQuery.ariaFix]{@link external:jQuery.ariaFix} will convert the names of\n * WAI-ARIA attributes.\n * <br>[jQuery.ariaHooks]{@link external:jQuery.ariaHooks} allow special\n * functionality to be defined for specific WAI-ARIA attributes.\n * <br><br>\n * <strong>Manipulating Landmarks</strong>\n * <br>[jQuery#role]{@link external:jQuery#role},\n * [jQuery#addRole]{@link external:jQuery#addRole} and\n * [jQuery#removeRole]{@link external:jQuery#removeRole} handling WAI-ARIA\n * landmarks.\n * <br><br>\n * <strong>Helper Functions for Common Functionality</strong>\n * <br>[jQuery#identify]{@link external:jQuery#identify} for generating element\n * IDs as necessary.\n * <br>[jQuery#ariaFocusable]{@link external:jQuery#ariaFocusable} for toggling\n * focusability.\n * <br>[jQuery.normaliseAria]{@link external:jQuery.normaliseAria} for\n * simplifying the WAI-ARIA attributes (aliased as\n * [jQuery.normalizeAria]{@link external:jQuery.normalizeAria}).\n * <br><br>\n * The files can be downloaded on\n * [GitHub]{@link https://github.com/Skateside/jquery-aria}.\n *\n * @author James \"Skateside\" Long <sk85ide@hotmail.com>\n * @version 0.7.0a\n * @license MIT\n */\n\n// Source: /src/doc/external/jQuery.js\n/**\n * @external jQuery\n * @see [jQuery]{@link http://jquery.com}\n */\n\n// Source: /src/doc/callback/Attribute_Callback.js\n/**\n * The [jQuery#aria]{@link external:jQuery#aria},\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef} and\n * [jQuery#ariaState]{@link external:jQuery#ariaState} methods all take\n * functions to set their value. The functions all have the same signature,\n * described here. It is important to remember that the value this function\n * returns will be treated as if it had originally been passed to the\n * function. See\n * [jQuery#attr]{@link http://api.jquery.com/attr/#attr-attributeName-function}\n * for more information and examples.\n *\n * @callback Attribute_Callback\n * @this     HTMLElement\n *           The element being referenced.\n * @param    {Number} index\n *           The index of the current element from within the overall jQuery\n *           collection.\n * @param    {String|undefined} attr\n *           Current attribute value (undefined if the element does not\n *           currently have the attribute assigned).\n * @return   {String}\n *           The value that should be passed to the function.\n *\n * @example\n * $(\"#one\").aria(\"label\", function (i, attr) {\n *     return \"Test\";\n * });\n * // is the same as\n * $(\"#one\").aria(\"label\", \"Test\");\n *\n * @example <caption>Elements without the attribute pass undefined</caption>\n * // Markup is\n * // <div id=\"one\"></div>\n *\n * $(\"#one\").aria(\"label\", function (i, attr) {\n *     return Object.prototype.toString.call(attr);\n * });\n *\n * // Now markup is\n * // <div id=\"one\" aria-label=\"[object Undefined]\"></div>\n */\n\n// Source: /src/doc/typedef/ARIA_state.js\n/**\n * A boolean or the string \"mixed\" (always in lower case). This type will\n * be undefined when trying to read a state that has not been set on the\n * element.\n *\n * @typedef {Boolean|String|undefined} ARIA_state\n *\n * @example\n * // Markup is\n * // <div id=\"one\" aria-checked=\"true\"></div>\n * // <div id=\"two\" aria-checked=\"false\"></div>\n * // <div id=\"three\" aria-checked=\"mixed\"></div>\n * // <div id=\"four\"></div>\n *\n * $(\"#one\").ariaState(\"checked\");   // -> true\n * $(\"#two\").ariaState(\"checked\");   // -> false\n * $(\"#three\").ariaState(\"checked\"); // -> \"mixed\"\n * $(\"#four\").ariaState(\"checked\");  // -> undefined\n */\n\n// Source: /src/doc/typedef/ARIA_hook.js\n/**\n * A hook for a WAI-ARIA attribute. Every property is optional so there is no\n * need to specify one to execute the default functionality.\n * <br><br>\n * Be aware that these hooks only affect the aria methods;\n * [jQuery#attr]{@link http://api.jquery.com/attr/} and\n * [jQuery#prop]{@link http://api.jquery.com/prop/} will not be affected by any\n * changes here. There are similar <code>jQuery.attrHooks</code> and\n * <code>jQuery.propHooks</code> (for set and get) that work in the same way if\n * you need to completely control attribute/property setting.\n *\n * @typedef  {Object}          ARIA_hook\n * @property {ARIA_hook_set}   [set]\n *           Handles setting the attribute.\n * @property {ARIA_hook_get}   [get]\n *           Handles getting the attribute.\n * @property {ARIA_hook_has}   [has]\n *           Handlers checking whether or not the attribute is assigned.\n * @property {ARIA_hook_unset} [unset]\n *           Handles removing the attribute.\n */\n\n/**\n * Handles the setting of a WAI-ARIA attribute. If the function returns a value,\n * that value is used to set the attribute; returning null, undefined, or not\n * returning anything will prevent the normal attribute setting process from\n * completing.\n * <br><br>\n * When setting an attribute, please do not use\n * [jQuery#aria]{@link external:jQuery#aria},\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef} or\n * [jQuery#ariaState]{@link external:jQuery#ariaState} as this can create an\n * infinite loop.\n *\n * @typedef {Function}    ARIA_hook_set\n * @param   {HTMLElement}           element\n *          Element whose attribute should be modified.\n * @param   {Boolean|Number|String} value\n *          Value of the attribute in the form given to the aria function.\n * @param   {String}                attribute\n *          Full attribute name, lower case and including \"aria-\" prefix.\n * @return  {?}\n *          Possible conversion of the value.\n *\n * @example <caption>Setting fictitious \"volume\" or \"soundsetup\" attributes</caption>\n * $.ariaHooks.volume = {\n *     // Let's assume that the value must be a positive integer and that any\n *     // other value should be ignored.\n *     set: function (element, value, attribute) {\n *         var posInt = Math.floor(Math.abs(value));\n *         return isNaN(posInt)\n *             ? undefined\n *             : posInt;\n *     }\n * };\n * $.ariaHooks.soundsetup = {\n *     // Let's assume that the value can only be something in a set list and\n *     // that everything else should be ignored.\n *     set: function (element, value, attribute) {\n *         var values = [\"mono\", \"stereo\", \"5.1\"];\n *         return values.indexOf(value) > -1\n *             ? value\n *             : undefined;\n *     }\n * };\n *\n * // Markup is:\n * // <div id=\"one\"></div>\n * // <div id=\"two\"></div>\n *\n * $(\"#one\").aria({\n *     volume: 5,\n *     soundsetup: \"mono\"\n * });\n * $(\"#two\").aria({\n *     volume: \"loud\",\n *     soundsetup: \"legendary\"\n * });\n *\n * // Now markup is:\n * // <div id=\"one\" aria-volume=\"5\" aria-soundsetup=\"mono\"></div>\n * // <div id=\"two\"></div>\n */\n\n/**\n * Handles the getting of a WAI-ARIA attribute. The function takes the element\n * and should return the value that the jQuery aria methods should return.\n * <br><br>\n * When getting an attribute, please do not use\n * [jQuery#aria]{@link external:jQuery#aria},\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef} or\n * [jQuery#ariaState]{@link external:jQuery#ariaState} as this can create an\n * infinite loop.\n *\n * @typedef {Function}    ARIA_hook_get\n * @param   {HTMLElement} element\n *          Element whose attribute value should be returned.\n * @param   {String}      attribute\n *          Full attribute name, lower case and including \"aria-\" prefix.\n * @return  {?Boolean|Number|String}\n *          Value of the attribute.\n *\n * @example <caption>Getting a fictitious \"volume\" attribute</caption>\n * $.ariaHooks.volume = {\n *     // Let's assume that the value will be a positive integer and if it\n *     // contains another value, or is missing, it defaults to 0.\n *     get: function (element, attribute) {\n *         var value = element.getAttribute(attribute);\n *         return (value === null || isNaN(value) || value < 0)\n *             ? 0\n *             : Math.floor(value);\n *     }\n * };\n *\n * // Markup is:\n * // <div id=\"one\" aria-volume=\"5\"></div>\n * // <div id=\"two\" aria-volume=\"loud\"></div>\n *\n * $(\"#one\").aria(\"volume\"); // -> 5\n * $(\"#two\").aria(\"volume\"); // -> 0\n */\n\n/**\n * Handles checking whether or not the WAI-ARIA attribute exists on the element\n * and it should return a boolean. Currently this functionality is not exposed\n * in an aria method, but the existence of a WAI-ARIA attribute will be checked\n * before getting occurs (and the {@link ARIA_hook_get} function executes).\n *\n * @typedef {Function}    ARIA_hook_has\n * @param   {HTMLElement} element\n *          Element whose attribute should be checked.\n * @param   {String}      attribute\n *          Full attribute name, lower case and including \"aria-\" prefix.\n * @return  {Boolean}\n *          Whether or not the attribute exists on the element (true if it\n *          does, false otherwise).\n *\n * @example <caption>Checking for a fictitious \"volume\" attribute</caption>\n * $.ariaHooks.volume = {\n *     get: function (element, attribute) {\n *         console.log(\"hi\");\n *         return element.getAttribute(attribute);\n *     },\n *     // Let's assume that the attribute has to contain a positive integer and\n *     // will be considered non-existent if it contains anything else.\n *     has: function (element, attribute) {\n *         var value = element.getAttribute(attribute);\n *         var intVal = parseInt(value, 10);\n *         return value !== null && intVal === +value && intVal <= 0;\n *     }\n * };\n *\n * // Markup is:\n * // <div id=\"one\" aria-volume=\"5\"></div>\n * // <div id=\"two\" aria-volume=\"loud\"></div>\n *\n * $(\"#one\").aria(\"volume\");\n * // Logs: \"hi\"\n * // -> \"5\"\n * $(\"#two\").aria(\"volume\"); // -> undefined\n */\n\n/**\n * Checks to see if the WAI-ARIA attribute should be removed. If the function\n * returns <code>true</code> (or a truthy value) then the attribute will be\n * removed, a falsy value will prevent the attribute being removed through the\n * aria methods (although there is nothing stopping it being removed in another\n * way or even through the function itself).\n * <br><br>\n * When removing an attribute, please do not use\n * [jQuery#removeAria]{@link external:jQuery#removeAria},\n * [jQuery#removeAriaRef]{@link external:jQuery#removeAriaRef} or\n * [jQuery#removeAriaState]{@link external:jQuery#removeAriaState} as this can\n * create an infinite loop.\n *\n * @typedef {Function}    ARIA_hook_unset\n * @param   {HTMLElement} element\n *          Element whose attribute should be removed.\n * @param   {String}      attribute\n *          Full attribute name, lower case and including \"aria-\" prefix.\n * @return  {Boolean}\n *          Whether or not the attribute should be removed.\n *\n * @example <caption>Removing a fictitious \"volume\" attribute</caption>\n * $.ariaHooks.volume = {\n *     // Let's assume that there is also a \"soundsetup\" attribute and that it\n *     // requires the \"volume\" attribute to exist, thus if \"volume\" is removed,\n *     // \"soundsetup\" should be removed as well.\n *     unset: function (element, attribute) {\n *         element.removeAttribute(\"aria-soundsetup\");\n *         return true;\n *     }\n * };\n *\n * // Markup is:\n * // <div id=\"one\" aria-volume=\"5\" aria-soundsetup=\"mono\"></div>\n *\n * $(\"#one\").removeAria(\"volume\");\n *\n * // Now markup is\n * // <div id=\"one\"></div>\n */\n\n// Source: /src/doc/typedef/jQuery_param.js\n/**\n * Any parameter that can be passed to\n * [jQuery's $ function]{@link http://api.jquery.com/jQuery/}. Be aware that\n * if the object (or Array or NodeList) contains multiple elements, only the\n * first will be used when getting information.\n *\n * @typedef {Array|Element|jQuery|NodeList|String} jQuery_param\n */\n\n// Source: /src/global/variables.js\n\n\n// A simple check to see if there is a global Proxy function and it's native.\n// Although this isn't fool-proof, it's a fairly reliable way of checking\n// whether or not the browser supports Proxy.\nvar IS_PROXY_AVAILABLE = (\n    typeof window.Proxy === \"function\"\n    && window.Proxy.toString().indexOf(\"[native code]\") > -1\n);\n\n// Source: /src/global/identify.js\n\n\n/**\n * Helper function for identifying the given <code>reference</code>. The ID of\n * the first match is returned - see\n * [jQuery#identify]{@link external:jQuery#identify} for full details.\n *\n * @global\n * @private\n * @param   {jQuery_param} reference\n *          Element to identify.\n * @return  {String}\n *          ID of the element.\n */\nvar identify = function (reference) {\n\n    return $(reference).identify();\n\n};\n\n// Source: /src/global/identity.js\n/**\n * An identity function that simply returns whatever it is given without\n * modifying it. This can be useful for cases when a modification function is\n * needed but optional.\n *\n * @global\n * @private\n * @param   {?} x\n *          Object to return.\n * @return  {?}\n *          Original object.\n *\n * @example\n * identity(\"a\");           // -> \"a\"\n * identity(\"a\", \"b\");      // -> \"a\", only first argument is returned.\n * identity.call(\"b\", \"a\"); // -> \"a\", context has no effect.\n */\nvar identity = function (x) {\n\n    return x;\n\n};\n\n// Source: /src/global/interpretString.js\n/**\n * Interprets the given object as a string. If the object is <code>null</code>\n * or <code>undefined</code>, an empty string is returned.\n *\n * @global\n * @private\n * @param   {?} string\n *          Object to interpret.\n * @return  {String}\n *          Interpreted string.\n *\n * @example\n * interpretString(\"1\");       // -> \"1\"\n * interpretString(1);         // -> \"1\"\n * interpretString([1, 2]);    // -> \"1,2\"\n * interpretString(null);      // -> \"\"\n * interpretString(undefined); // -> \"\"\n * interpretString();          // -> \"\"\n */\nvar interpretString = function (string) {\n\n    return (string === null || string === undefined)\n        ? \"\"\n        : String(string);\n\n};\n\n// Source: /src/global/isElement.js\n/**\n * Returns <code>true</code> if the given <code>element</code> is an HTML\n * element.\n *\n * @global\n * @private\n * @param   {?} element\n *          Object to test.\n * @return  {Boolean}\n *          true if <code>element</code> is an HTMLElement.\n *\n * @example\n * isElement(document.createElement(\"div\")); // -> true\n * isElement(document.body); // -> true\n * isElement(document.createTextNode(\"\")); // -> false\n * isElement($(\"body\")); // -> false\n * isElement($(\"body\")[0]); // -> true\n */\nvar isElement = function (element) {\n\n    // relying on polymorphism rather than instanceof is usually wise, but in\n    // this situation it'd be so much eaasier to simply type:\n    // return element instanceof HTMLElement;\n    return (\n        element !== null\n        && element !== undefined\n        && (/^\\[object\\sHTML(?:[A-Z][a-z]+)?Element\\]$/).test(element)\n        && typeof element.nodeName === \"string\"\n        && typeof element.nodeType === \"number\"\n    );\n\n};\n\n// Source: /src/global/memoise.js\n\n\n/**\n * Modifies a function so that the results are retrieved from a cache if\n * possible rather than from executing the function again. The cache is publicly\n * exposed (as the property <code>cache</code>) to allow it to be cleared,\n * forcing the function to re-execute.\n * <br><br>\n * If defined, the <code>resolver</code> is passed the same arguments as the\n * <code>handler</code>; it should return a string and that string will be used\n * as the key for <code>cache</code>. If a <code>resolver</code> isn't defined,\n * or isn't a function, the arguments are simply joined together as a\n * comma-separated string.\n *\n * @global\n * @private\n * @param   {Function} handler\n *          Function to convert.\n * @param   {Function} [resolver]\n *          Optional function for working out the key for the cache.\n * @return  {Function}\n *          Converted function.\n *\n * @example <caption>Basic example</caption>\n * var increase = function (number) {\n *     console.log(number);\n *     return number + 1;\n * };\n * var memIncrease = memoise(increase);\n *\n * memIncrease(1);\n * // Logs: 1\n * // -> 2\n * memIncrease(1); // -> 2\n * memincrease(2);\n * // Logs: 2\n * // -> 3\n * memIncrease(1); // -> 1\n * memIncrease.cache; // -> {\"1\": 2, \"2\": 3}\n *\n * @example <caption>Specifying a resolver</caption>\n * var sum = function (numbers) {\n *     return numbers.reduce(function (prev, curr) {\n *         return prev + curr;\n *     }, 0);\n * };\n * var memSum = memoise(sum, function (numbers) {\n *     return JSON.stringify(numbers);\n * });\n * memSum([1, 2, 3]); // -> 6\n * memSum.cache; // -> {\"[1,2,3]\": 6}\n */\nvar memoise = function (handler, resolver) {\n\n    var hasOwn = Object.prototype.hasOwnProperty;\n    var slice = Array.prototype.slice;\n    var memoised = function mem() {\n\n        var args = slice.call(arguments);\n        var key = typeof resolver === \"function\"\n            ? resolver.apply(undefined, args)\n            : args.join(\",\");\n        var response = mem.cache[key];\n\n        if (!hasOwn.call(mem.cache, key)) {\n\n            response = handler.apply(this, args);\n            mem.cache[key] = response;\n\n        }\n\n        return response;\n\n    };\n\n    memoised.cache = {};\n\n    return memoised;\n\n};\n\n// Source: /src/global/normalise.js\n\n\n/**\n * Normalises a WAI-ARIA attribute name so that it's always lower case and\n * always stars with <code>aria-</code>. If the unprefixed value appears in\n * [jQuery.ariaFix]{@link external:jQuery.ariaFix} then the mapped version is\n * used before being prefixed.\n * <br><br>\n * The results of this function are cached to help reduce processing. This is\n * exposed as <code>jQuery.normaliseAria.cache</code> if needed but there is no\n * need to clear the cache after modifying\n * [jQuery.ariaFix]{@link external:jQuery.ariaFix} - changes are automatically\n * considered in the caching process.\n * <br><br>\n * This function is aliased as\n * [jQuery.normalizeAria]{@link external:jQuery.normalizeAria}.\n *\n * @function\n * @alias    external:jQuery.normaliseAria\n * @memberof external:jQuery\n * @param    {String} name\n *           Attribute name to normalise.\n * @return   {String}\n *           Normalised attribute name.\n * @property {Object.<String>} cache\n *           The cache of requests to responses.\n *\n * @example <caption>Basic example</caption>\n * $.normaliseAria(\"label\");      // -> \"aria-label\"\n * $.normaliseAria(\"LABEL\");      // -> \"aria-label\"\n * $.normaliseAria(\"aria-label\"); // -> \"aria-label\"\n * $.normaliseAria();             // -> \"aria-\"\n *\n * @example <caption>Alias</caption>\n * $.normalizeAria(\"label\");      // -> \"aria-label\"\n * $.normalizeAria(\"LABEL\");      // -> \"aria-label\"\n * $.normalizeAria(\"aria-label\"); // -> \"aria-label\"\n * $.normalizeAria();             // -> \"aria-\"\n *\n * @example <caption>Mapped attribute</caption>\n * // $.ariaFix = {labeledby: \"labelledby\"}\n * $.normaliseAria(\"labeledby\");      // -> \"aria-labelledby\"\n * $.normaliseAria(\"LABELEDBY\");      // -> \"aria-labelledby\"\n * $.normaliseAria(\"aria-labeledby\"); // -> \"aria-labelledby\"\n *\n * @example <caption>The cache</caption>\n * $.normaliseAria(\"busy\");    // -> \"aria-busy\"\n * $.normaliseAria(\"busy\");    // -> \"aria-busy\" (from cache)\n * $.normaliseAria(\"checked\"); // -> \"aria-checked\"\n * $.normaliseAria(\"busy\");    // -> \"aria-busy\" (from cache)\n * $.normaliseAria.cache;\n * // -> {\"busy\": \"aria-busy\", \"checked\": \"aria-checked\"}\n */\nvar normalise = memoise(\n    function (name) {\n\n        var prefix = \"aria-\";\n        var lower = interpretString(name).toLowerCase();\n        var full = (/^aria-/).test(lower)\n            ? lower\n            : prefix + lower;\n        var stem = full.slice(prefix.length);\n        var map = $.ariaFix[stem];\n\n        if (map) {\n\n            stem = map;\n            full = prefix + stem;\n\n        }\n\n        return full;\n\n    },\n    IS_PROXY_AVAILABLE\n        ? identity\n        : function (name) {\n\n            return name + \"|\" + JSON.stringify($.ariaFix);\n\n        }\n);\n\n// Source: /src/global/toWords.js\n\n\n/**\n * Converts the given string into an array of the words. The <code>string</code>\n * argument is converted into a string before being split - see\n * {@link interpretString} for more information.\n *\n * @global\n * @private\n * @param   {String} string\n *          String (or other variable type) to break into words.\n * @return  {Array.<String>}\n *          Words from the string.\n *\n * @example\n * toWords(\"abc def\");  // -> [\"abc\", \"def\"]\n * toWords(\"abc  def\"); // -> [\"abc\", \"def\"]\n * toWords(\"\")          // -> []\n * toWords(\"   \");      // -> []\n */\nvar toWords = function (string) {\n\n    return interpretString(string).split(/\\s+/).filter(identity);\n\n};\n\n// Source: /src/global/handlers.js\nvar HANDLER_PROPERTY = \"property\";\nvar HANDLER_REFERENCE = \"reference\";\nvar HANDLER_STATE = \"state\";\n\n/**\n * Handlers for properties, references and states. Each handler has at least a\n * <code>get</code> and <code>set</code> method to write and read the values.\n * <code>has</code> methods check whether the property exists,\n * <code>unset</code> removes the property.\n *\n * {@link handlers.reference} and {@link handlers.state} defer to\n * {@link handlers.property} (they don't inherit from {@link handlers.property}\n * but they may do in another implementation - any functionality they don't have\n * will be taken from {@link handlers.property}).\n *\n * @global\n * @namespace\n * @private\n */\nvar handlers = {};\n\n// Source: /src/global/handlers/property.js\n\n\n/**\n * Handles WAI-ARIA properties without modifying the values any more than it\n * needs to. These methods also act as the fallback for other namespaces such as\n * {@link handlers.reference} and {@link handlers.state}.\n * <br>{@link handlers.property.parse} parses the attribute name.\n * <br>{@link handlers.property.get} gets the value of the property.\n * <br>{@link handlers.property.set} sets a property.\n * <br>{@link handlers.property.has} checks to see if the property exists.\n * <br>{@link handlers.property.unset} removes the property.\n *\n * @alias     property\n * @memberof  handlers\n * @namespace\n * @private\n */\nhandlers[HANDLER_PROPERTY] = {\n\n    /**\n     * Parses the name and returns an object with the normalised name (see\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria} and the\n     * un-prefixed attribute name.\n     *\n     * @param  {String} name\n     *         Attribute name to parse.\n     * @return {Object.<String>}\n     *         An object with \"full\" and \"stem\" properties.\n     *\n     * @example\n     * handlers.property.parse(\"busy\");\n     * // -> {full: \"aria-busy\", stem: \"busy\"}\n     */\n    parse: function (name) {\n\n        var normal = normalise(name);\n\n        return {\n            full: normal,\n            stem: normal.slice(5)\n        };\n\n    },\n\n    /**\n     * Sets the property of an element. The <code>value</code> is unchanged\n     * (other than normal string coercion) and the <code>name</code> is\n     * normalised into a WAI-ARIA property (see\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}).\n     * <br><br>\n     * If <code>element</code> is not an element (see {@link isElement}) then no\n     * action will be taken.\n     * <br><br>\n     * If <code>value</code> is a function, it is treated like an\n     * {@link Attribute_callback}. This is for consistency with\n     * [jQuery#attr]{@link http://api.jquery.com/attr/}.\n     * <br><br>\n     * A <code>convert</code> function can also be passed. That function will\n     * convert <code>value</code> (if <code>value</code> is a function,\n     * <code>convert</code> will convert the result) before assigning it. If\n     * <code>convert</code> is ommitted or not a function then {@link identity}\n     * is used so <code>value</code> will not be changed.\n     *\n     * @private\n     * @param   {Element}  element\n     *          Element to have a property set.\n     * @param   {String}   name\n     *          WAI-ARIA property to set.\n     * @param   {?}        value\n     *          Value of the property.\n     * @param   {Number}   [index]\n     *          Optional index of <code>element</code> within the jQuery object.\n     *          This is needed to keep consistency with the\n     *          [jQuery#attr]{@link http://api.jquery.com/attr/} function and\n     *          should be derived rather than manually passed.\n     * @param   {Function} [convert=identity]\n     *          Optional conversion process. If ommitted, no conversion occurs.\n     *\n     * @example <caption>Setting a property</caption>\n     * // Markup is:\n     * // <div id=\"one\"></div>\n     *\n     * var element = document.getElementById(\"one\");\n     * handlers.property.set(element, \"label\", \"test\");\n     *\n     * // Now markup is:\n     * // <div id=\"one\" aria-label=\"test\"></div>\n     *\n     * @example <caption>Setting a property using a function</caption>\n     * // Markup is:\n     * // <div id=\"one\" aria-label=\"test\"></div>\n     *\n     * var element = document.getElementById(\"one\");\n     * handlers.property.set(element, \"label\", function (i, attr) {\n     *     return this.id + \"__\" + i + \"__\" + attr;\n     * }, 0);\n     *\n     * // Now markup is:\n     * // <div id=\"one\" aria-label=\"one__0__test\"></div>\n     *\n     * @example <caption>Converting the result</caption>\n     * // Markup is:\n     * // <div id=\"one\" aria-label=\"test\"></div>\n     *\n     * var element = document.getElementById(\"one\");\n     * handlers.property.set(element, \"label\", function (i, attr) {\n     *     return this.id + \"__\" + i + \"__\" + attr;\n     * }, 0, function (value) {\n     *     return value.toUpperCase();\n     * });\n     *\n     * // Now markup is:\n     * // <div id=\"one\" aria-label=\"ONE__0__TEST\"></div>\n     */\n    set: function (element, name, value, index, convert) {\n\n        var prop = handlers[HANDLER_PROPERTY].parse(name);\n        var hook = $.ariaHooks[prop.stem];\n\n        if (isElement(element)) {\n\n            if ($.isFunction(value)) {\n\n                value = value.call(\n                    element,\n                    index,\n                    element.getAttribute(prop.full)\n                );\n\n            }\n\n            if (!$.isFunction(convert)) {\n                convert = identity;\n            }\n\n            if (value !== undefined && value !== null) {\n\n                if (hook && hook.set) {\n                    value = hook.set(element, value, prop.full);\n                }\n\n                value = convert(value);\n\n                if (value !== undefined && value !== null) {\n                    element.setAttribute(prop.full, interpretString(value));\n                }\n\n            }\n\n        }\n\n    },\n\n    /**\n     * Checks to see if the given <code>name</code> exists on the given\n     * <code>element</code>. The <code>name</code> is always normalised (see\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}) and if\n     * <code>element</code> is not an element (see {@link isElement}) then\n     * <code>false</code> will always be returned.\n     *\n     * @private\n     * @param   {Element} element\n     *          Element to test.\n     * @param   {String}  name\n     *          WAI-ARIA property to check.\n     * @return  {Boolean}\n     *          Whether or not the element has the given property.\n     *\n     * @example\n     * // Markup is:\n     * // <div id=\"one\" aria-label=\"test\"></div>\n     *\n     * var element = document.getElementById(\"one\");\n     * handlers.property.has(element, \"label\"); // -> true\n     * handlers.property.has(element, \"busy\");  // -> false\n     */\n    has: function (element, name) {\n\n        var prop = handlers[HANDLER_PROPERTY].parse(name);\n        var hook = $.ariaHooks[prop.stem];\n\n        return isElement(element)\n            ? (hook && hook.has)\n                ? hook.has(element, prop.full)\n                : element.hasAttribute(prop.full)\n            : false;\n\n    },\n\n    /**\n     * Gets the value of the WAI-ARIA property from the given\n     * <code>element</code> and returns it unchanged. The <code>name</code> is\n     * normalised (see\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). If\n     * <code>element</code> is not an element (see {@link isElement}) or\n     * <code>name</code> is not recognised (see\n     * {@link handlers.property.has}) then <code>undefined</code> is returned.\n     *\n     * @private\n     * @param   {Element}          element\n     *          Element to access.\n     * @param   {String}           name\n     *          WAI-ARIA property to access.\n     * @return  {String|undefined}\n     *          WAI-ARIA attribute or undefined if the attribute isn't set.\n     *\n     * @example\n     * // Markup is:\n     * // <div id=\"one\" aria-label=\"test\"></div>\n     *\n     * var element = document.getElementById(\"one\");\n     * handlers.property.get(element, \"label\"); // -> \"test\"\n     * handlers.property.get(element, \"busy\"); // -> undefined\n     */\n    get: function (element, name) {\n\n        var handler = handlers[HANDLER_PROPERTY];\n        var prop = handler.parse(name);\n        var hook = $.ariaHooks[prop.stem];\n        var response = handler.has(element, name)\n            ? (hook && hook.get)\n                ? hook.get(element, prop.full)\n                : element.getAttribute(prop.full)\n            : undefined;\n\n        // getAttribute can return null, normalise to undefined.\n        return response === null\n            ? undefined\n            : response;\n\n    },\n\n    /**\n     * Removes a WAI-ARIA attribute from the given <code>element</code>. The\n     * <code>name</code> if normalised (see\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}) and if\n     * <code>element</code> is not an element (see {@link isElement}) then no\n     * action is taken.\n     *\n     * @private\n     * @param   {Element} element\n     *          Element to modify.\n     * @param   {String}  name\n     *          WAI-ARIA attribute to remove.\n     *\n     * @example\n     * // Markup is:\n     * // <div id=\"one\" aria-label=\"test\"></div>\n     *\n     * var element = document.getElementById(\"one\");\n     * handlers.property.unset(element, \"label\");\n     *\n     * // Now markup is:\n     * // <div id=\"one\"></div>\n     */\n    unset: function (element, name) {\n\n        var prop = handlers[HANDLER_PROPERTY].parse(name);\n        var hook = $.ariaHooks[prop.stem];\n\n        if (isElement(element)) {\n\n            if (!hook || !hook.unset || hook.unset(element, prop.full)) {\n                element.removeAttribute(prop.full);\n            }\n\n        }\n\n    }\n\n};\n\n// Source: /src/global/handlers/reference.js\n\n\n/**\n * Handles modifying WAI-ARIA references. Unlike {@link handlers.property}, this\n * will create references to elements and return them. The only defined methods\n * are:\n * <br>{@link handlers.reference.set} sets a reference.\n * <br>{@link handlers.reference.get} gets a reference.\n *\n * @alias     reference\n * @memberof  handlers\n * @namespace\n * @private\n */\nhandlers[HANDLER_REFERENCE] = {\n\n    /**\n     * Adds the WAI-ARIA reference to <code>element</code>. This differs from\n     * {@link handlers.property.set} in that <code>reference</code> is passed\n     * through [jQuery's $ function]{@link http://api.jquery.com/jquery/} and\n     * identified (see [jQuery#identify]{@link external:jQuery#identify}) with\n     * the ID of the first match being used. There is also no\n     * <code>convert</code> parameter.\n     * <br><br>\n     * The <code>name</code> is still normalised (see\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). If\n     * <code>element</code> is not an element (see {@link isElement}) then no\n     * action is taken.\n     *\n     * @private\n     * @param   {Element}      element\n     *          Element to modify.\n     * @param   {String}       name\n     *          WAI-ARIA attribute to set.\n     * @param   {jQuery_param} reference\n     *          Element to reference.\n     * @param   {Number}       index\n     *          Index of <code>element</code> within the collection.\n     *\n     * @example\n     * // Markup is:\n     * // <div class=\"one\"></div>\n     * // <div class=\"two\"></div>\n     *\n     * var element = document.querySelector(\".one\");\n     * handlers.reference.set(element, \"labelledby\", \".two\");\n     *\n     * // Now markup is:\n     * // <div class=\"one\" aria=labelledby=\"anonymous0\"></div>\n     * // <div class=\"two\" id=\"anonymous0\"></div>\n     */\n    set: function (element, name, reference, index) {\n\n        handlers[HANDLER_PROPERTY].set(\n            element,\n            name,\n            reference,\n            index,\n            identify\n        );\n\n    },\n\n    /**\n     * Gets the reference from the given <code>element</code> and returns it as\n     * a <code>jQuery</code> object. This differs from\n     * {@link handlers.property.get} in that the match is assumed to be an ID\n     * and a DOM lookup is done based upon that. The <code>name</code> is still\n     * normalised (see\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). If the\n     * WAI-ARIA attribute is not found (see {@link handlers.property.has} then\n     * <code>undefined</code> is returned.\n     *\n     * @private\n     * @param   {Element}          element\n     *          Element to check.\n     * @param   {String}           name\n     *          WAI-ARIA reference.\n     * @return  {jQuery|undefined}\n     *          jQuery object representing the reference or undefined if the\n     *          attribute isn't set.\n     *\n     * @example\n     * // Markup is:\n     * // <div id=\"one\" aria=labelledby=\"two\"></div>\n     * // <div id=\"two\"></div>\n     *\n     * var element = document.getElementById(\"one\");\n     * handlers.reference.get(element, \"labelledby\");\n     * // -> $(<div id=\"two\">)\n     * handlers.reference.get(element, \"controls\");\n     * // -> undefined\n     */\n    get: function (element, name) {\n\n        var handler = handlers[HANDLER_PROPERTY];\n\n        return handler.has(element, name)\n            ? $(\"#\" + handler.get(element, name))\n            : undefined;\n\n    }\n\n};\n\n// Source: /src/global/handlers/state.js\n\n\nvar REGEXP_BOOLEAN = /^(?:true|false)$/;\nvar VALUE_MIXED = \"mixed\";\n\n/**\n * Handles WAI-ARIA states. This differs from {@link handlers.property} in that\n * values are coerced into booleans before being set and a boolean (or the\n * string \"mixed\") will be returned.\n * <br>{@link handlers.state.read} converts the value into a boolean.\n * <br>{@link handlers.state.set} sets the state.\n * <br>{@link handlers.state.get} gets the state.\n *\n * @alias     state\n * @memberof  handlers\n * @namespace\n * @private\n */\nhandlers[HANDLER_STATE] = {\n\n    /**\n     * Reads the raw value and converts it into a boolean or the string\n     * <code>\"mixed\"</code> (always lower case). If <code>raw</code> cannot be\n     * correctly converted, it is assumed to be <code>true</code>.\n     *\n     * @private\n     * @param   {?} raw\n     *          Value to read.\n     * @return  {Boolean|String}\n     *          Converted value.\n     *\n     * @example <caption>Converting values</caption>\n     * handlers.state.read(true);    // -> true\n     * handlers.state.read(\"false\"); // -> false\n     * handlers.state.read(\"1\");     // -> true\n     * handlers.state.read(0);       // -> false\n     * handlers.state.read(\"mixed\"); // -> \"mixed\"\n     *\n     * @example <caption>Unrecognised values default to true</caption>\n     * handlers.state.read(\"2\");      // -> true\n     * handlers.state.read(-1);       // -> true\n     * handlers.state.read([]);       // -> true\n     * handlers.state.read(\"mixed.\"); // -> true\n     */\n    read: function readState(raw) {\n\n        var state = true;\n\n        switch (typeof raw) {\n\n        case \"boolean\":\n\n            state = raw;\n            break;\n\n        case \"string\":\n\n            raw = raw.toLowerCase();\n\n            if (raw === VALUE_MIXED) {\n                state = raw;\n            } else if (raw === \"1\" || raw === \"0\") {\n                state = readState(+raw);\n            } else if (REGEXP_BOOLEAN.test(raw)) {\n                state = raw === \"true\";\n            }\n\n            break;\n\n        case \"number\":\n\n            if (raw === 0 || raw === 1) {\n                state = !!raw;\n            }\n\n            break;\n\n        }\n\n        return state;\n\n    },\n\n    /**\n     * Sets the WAI-ARIA state defined in <code>name</code> on the given\n     * <code>element</code>. This differs from {@link handlers.property.set} in\n     * that <code>state</code> is converted into a boolean or\n     * <code>\"mixed\"</code> before being assigned (see\n     * {@link handlers.state.read}) and there is no <code>convert</code>\n     * paramter. The <code>name</code> is still normalised (see\n     * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}).\n     *\n     * @private\n     * @param   {Element} element\n     *          Element to modify.\n     * @param   {String}  name\n     *          WAI-ARIA attribute to set.\n     * @param   {?}       state\n     *          State to set.\n     * @param   {Number}  index\n     *          Index of <code>element</code> within the collection.\n     *\n     * @example\n     * // Markup is:\n     * // <div id=\"one\"></div>\n     * // <div id=\"two\"></div>\n     *\n     * var one = document.getElementById(\"one\");\n     * var two = document.getElementById(\"two\");\n     * handlers.state.set(one, \"busy\", true);\n     * handlers.state.set(two, \"checked\", \"mixed\");\n     *\n     * // Now markup is:\n     * // <div id=\"one\" aria-busy=\"true\"></div>\n     * // <div id=\"two\" aria-checked=\"mixed\"></div>\n     */\n    set: function (element, name, state, index) {\n\n        handlers[HANDLER_PROPERTY].set(\n            element,\n            name,\n            state,\n            index,\n            handlers[HANDLER_STATE].read\n        );\n\n    },\n\n    /**\n     * Reads the WAI-ARIA state on <code>element</code>. This differs from\n     * {@link handlers.property.get} in that the result is converted into a\n     * boolean or the strign `\"mixed\"` before being returned. The\n     * <code>name</code> is still normalised (see {@link jQuery.normaliseAria}).\n     *\n     * @private\n     * @param   {Element}    element\n     *          Element to access.\n     * @param   {String}     name\n     *          WAI-ARIA state to read.\n     * @return  {ARIA_state}\n     *          State of the WAI-ARIA property.\n     *\n     * @example\n     * // Markup is:\n     * // <div id=\"one\" aria-busy=\"true\" aria-checked=\"mixed\"></div>\n     *\n     * var element = document.getElementById(\"one\");\n     * handlers.state.get(element, \"busy\");     // -> true\n     * handlers.state.get(element, \"checked\");  // -> \"mixed\"\n     * handlers.state.get(element, \"disabled\"); // -> undefined\n     */\n    get: function (element, name) {\n\n        var handler = handlers[HANDLER_PROPERTY];\n        var state;\n        var value;\n\n        if (handler.has(element, name)) {\n\n            value = handler.get(element, name).toLowerCase();\n            state = value === VALUE_MIXED\n                ? value\n                : (REGEXP_BOOLEAN.test(value) && value === \"true\");\n\n        }\n\n        return state;\n\n    }\n\n};\n\n// Source: /src/global/access.js\n\n\n/**\n * This function handles all the heavy lifting of getting or setting WAI-ARIA\n * attributes. It is designed to be all that's necessary for\n * [jQuery#aria]{@link external:jQuery#aria},\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef} and\n * [jQuery#ariaState]{@link external:jQuery#ariaState}. This function will check\n * its arguments to determine whether it should be used as a getter or a setter\n * and passes the appropriate arguments to the {@link handlers} methods based on\n * <code>type</code> (which will default to {@link handlers.property} if\n * ommitted or not recognised).\n * <br><br>\n * The return value is based on the type of action being performed. If this\n * function is setting then a jQuery object of the matches is returned (which is\n * almost always <code>jQelements</code>); if the function is a getter then the\n * results are returned for the first element in <code>jQelements</code>.\n * <br><br>\n * Although this description is not especially extensive, the code should be\n * very easy to follow and commented should there be any need to modify it. Once\n * the correct arguments are being passed to the appropriate {@link handlers}\n * method, they will take care of the rest.\n *\n * @global\n * @private\n * @param   {jQuery}            jQelements\n *          jQuery object to modify/access.\n * @param   {Object|String}     property\n *          Either WAI-ARIA names and values or the WAI-ARIA property name.\n * @param   {?}                 [value]\n *          Value to set.\n * @param   {String}            [type=\"property\"]\n *          Optional attribute type.\n * @return  {jQuery|ARIA_state}\n *          Either the jQuery object on which WAI-ARIA properties were set or\n *          the values of the WAI-ARIA properties.\n *\n * @example <caption>Setting a single property</caption>\n * // Markup is\n * // <div id=\"one\"></div>\n *\n * var jQone = $(\"#one\");\n * access(jQone, \"controls\", \"two\"); // -> jQuery(<div id=\"one\">)\n *\n * // Now markup is\n * // <div id=\"one\" aria-controls=\"two\">\n *\n * @example <caption>Setting multiple references</caption>\n * // Markup is\n * // <div id=\"one\"></div>\n * // <div id=\"two\"></div>\n *\n * var jQone = $(\"#one\");\n * access(jQone, {\n *     controls: $(\"div\").eq(1)\n * }, \"reference\"); // -> jQuery(<div id=\"one\">)\n *\n * // Now markup is\n * // <div id=\"one\" aria-controls=\"two\">\n * // <div id=\"two\"></div>\n *\n * @example <caption>Getting a state</caption>\n * // Markup is\n * // <div id=\"one\" aria-busy=\"true\"></div>\n *\n * var jQone = $(\"#one\");\n * access(jQone, \"busy\", undefined, \"state\"); // -> true\n */\nfunction access(jQelements, property, value, type) {\n\n    var tempProperty = property;\n    var isPropertyObject = $.isPlainObject(property);\n    var isGet = value === undefined && !isPropertyObject;\n\n    // Make sure the property value is in the expected format: an object for\n    // setting and a string for getting.\n    if (!isGet && !isPropertyObject) {\n\n        property = {};\n        property[tempProperty] = value;\n\n    }\n\n    // If we don't have or don't recognise the type, default to \"property\".\n    if (!type || !handlers[type]) {\n        type = HANDLER_PROPERTY;\n    }\n\n    return isGet\n        ? handlers[type].get(jQelements[0], property)\n        : jQelements.each(function (index, element) {\n\n            $.each(property, function (key, val) {\n                handlers[type].set(element, key, val, index);\n            });\n\n        });\n\n}\n\n// Source: /src/global/removeAttribute.js\n\n\n\n/**\n * Removes the named WAI-ARIA attribute from all elements in the current\n * collection. The <code>name</code> is normalised (see\n * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}). This function\n * is aliased as [jQuery#removeAriaRef]{@link external:jQuery#removeAriaRef} and\n * [jQuery#removeAriaState]{@link external:jQuery#removeAriaState}.\n *\n * @alias    removeAria\n * @memberof external:jQuery\n * @instance\n * @param    {String} name\n *           WAI-ARIA attribute to remove.\n * @return   {jQuery}\n *           jQuery attribute representing the elements modified.\n *\n * @example\n * // Markup is\n * // <div id=\"one\" aria-busy=\"true\"></div>\n *\n * $(\"#one\").removeAria(\"busy\"); // -> jQuery(<div id=\"one\">)\n *\n * // Now markup is:\n * // <div id=\"one\"></div>\n */\nfunction removeAttribute(name) {\n\n    return this.each(function (ignore, element) {\n        handlers[HANDLER_PROPERTY].unset(element, name);\n    });\n\n}\n\n// Source: /src/member/normaliseAria.js\n\n\n/**\n * Alias of [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}\n *\n * @function\n * @alias    external:jQuery.normalizeAria\n * @memberof external:jQuery\n * @param    {String} name\n *           Attribute name to normalise.\n * @return   {String}\n *           Normalised attribute name.\n * @property {Object.<String>} cache\n *           The cache of requests to responses.\n */\n$.normalizeAria = normalise;\n$.normaliseAria = normalise;\n\n// Source: /src/member/ariaFix.js\n\n\n/**\n * A map of unprefixed WAI-ARIA attributes that should be converted before being\n * normalised (see [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}).\n *\n * @alias    external:jQuery.ariaFix\n * @memberof external:jQuery\n * @type     {Object.<String>}\n *\n * @example <caption>Correcting a common typo</caption>\n * $.ariaFix.budy = \"busy\";\n * $.normaliseAria(\"budy\");      // -> \"aria-busy\"\n * $.normaliseAria(\"aria-budy\"); // -> \"aria-busy\"\n */\n$.ariaFix = {\n\n    // This is the US English spelling but the ccessibility API defined the\n    // attribute with the double L.\n    // https://www.w3.org/TR/wai-aria/states_and_properties#aria-labelledby\n    labeledby: \"labelledby\"\n\n};\n\n// If Proxy is available, we can use it to check whenever $.ariaFix is modified\n// and invalidate the cache of normalise() when it is. This is a lot more\n// efficient than always converting $.ariaFix to a JSON string to ensure the\n// cache is accurate.\nif (IS_PROXY_AVAILABLE) {\n\n    $.ariaFix = new Proxy($.ariaFix, {\n\n        set: function (target, name, value) {\n\n            normalise.cache = {};\n            target[name] = value;\n\n        }\n\n    });\n\n}\n\n// Source: /src/member/ariaHooks.js\n\n\n/**\n * A collection of hooks that change the behaviour of attributes being set,\n * retrieved, checked or removed (called [set]{@link ARIA_hook_set},\n * [get]{@link ARIA_hook_get}, [has]{@link ARIA_hook_has},\n * [unset]{@link ARIA_hook_unset} - see {@link ARIA_hook} for full details). The\n * name of the hook is always the un-prefixed WAI-ARIA attribute in lower case\n * after any mapping has occurred (see\n * [jQuery.ariaFix]{@link external:jQuery.ariaFix}). If you are ever in doubt,\n * the easiest way to know the key is to slice the normalised value:\n * <code>$.normaliseAria(__WAI-ARIA_ATTRIBUTE__).slice(5)</code> (see\n * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria} for more\n * information).\n * <br><br>\n * Do not use these functions to set different WAI-ARIA attributes without\n * setting the one being passed to the aria method; for example: do not create a\n * set for \"attribute1\" that sets \"attribute2\" instead - unless you add the same\n * conversion to <code>has</code>, <code>get</code> will not be triggered.\n * Instead, use [jQuery.ariaFix]{@link external:jQuery.ariaFix} to convert the\n * attribute name.\n * <br><br>\n * [jQuery#aria]{@link external:jQuery#aria},\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef},\n * [jQuery#ariaState]{@link external:jQuery#ariaState},\n * [jQuery#removeAria]{@link external:jQuery#removeAria},\n * [jQuery#removeAriaRef]{@link external:jQuery#removeAriaRef} and\n * [jQuery#removeAriaState]{@link external:jQuery#removeAriaState} all run\n * through these hooks (if they exist) and these hooks replace the functionality\n * of manipulating or checking the attributes after any conversion process has\n * occurred within the method itself.\n *\n * @alias    external:jQuery.ariaHooks\n * @memberof external:jQuery\n * @type     {Object.<ARIA_hook>}\n *\n * @example\n * // aria-level should be an integer greater than or equal to 1 so the getter\n * // should return an integer.\n * $.ariaHooks.level = {\n *     set: function (element, value) {\n *         var intVal = Math.max(1, Math.floor(value));\n *         if (!isNaN(intVal)) {\n *             element.setAttribute(\"aria-level\", intVal)\n *         }\n *     },\n *     get: function (element) {\n *         var value = element.getAttribute(\"aria-level\");\n *         var intVal = (Math.max(1, Math.floor(value));\n *         return (value === null || isNaN(intVal))\n *             ? undefined\n *             : intVal;\n *     }\n * };\n */\n$.ariaHooks = {\n\n    hidden: {\n\n        // Setting aria-hidden=\"false\" is considered valid, but removing the\n        // aria-hidden attribute has the same effect and I think it's tidier.\n        // https://www.w3.org/TR/wai-aria/states_and_properties#aria-hidden\n        set: function (element, value, name) {\n\n            var response;\n\n            if (value === false || +value === 0 || (/^false$/i).test(value)) {\n                element.removeAttribute(name);\n            } else {\n                response = value;\n            }\n\n            return response;\n\n        }\n\n    }\n\n};\n\n// Source: /src/instance/identify.js\n\n\n\nvar count = 0;\n\n/**\n * Identifies the first element in the collection by getting its ID. If the\n * element doesn't have an ID attribute, a unique on is generated and assigned\n * before being returned. If the collection does not have a first element then\n * <code>undefined</code> is returned.\n * <br><br>\n * IDs are a concatenation of \"anonymous\" and a hidden counter that is increased\n * each time. If the ID already exists on the page, that ID is skipped and not\n * assigned to a second element.\n *\n * @memberof external:jQuery\n * @instance\n * @alias    identify\n * @return   {String|undefined}\n *           The ID of the first element or undefined if there is no first\n *           element.\n *\n * @example <caption>Identifying elements</caption>\n * // Markup is\n * // <div class=\"one\"></div>\n * // <span class=\"one\"></span>\n *\n * $(\".one\").identify(); // -> \"anonymous0\"\n *\n * // Now markup is:\n * // <div class=\"one\" id=\"anonymous0\"></div>\n * // <span class=\"one\"></span>\n * // Running $(\".one\").identify(); again would not change the markup.\n *\n * @example <caption>Existing IDs are not duplicated</caption>\n * // Markup is:\n * // <div class=\"two\" id=\"anonymous1\"><!-- manually set --></div>\n * // <div class=\"two\"></div>\n * // <div class=\"two\"></div>\n *\n * $(\".two\").each(function () {\n *     $(this).identify();\n * });\n *\n * // Now markup is:\n * // <div class=\"two\" id=\"anonymous1\"><!-- manually set --></div>\n * // <div class=\"two\" id=\"anonymous0\"></div>\n * // <div class=\"two\" id=\"anonymous2\"></div>\n */\n$.fn.identify = function () {\n\n    var element = this[0];\n    var isAnElement = isElement(element);\n    var id = isAnElement\n        ? element.id\n        : undefined;\n\n    if (isAnElement && !id) {\n\n        do {\n\n            id = \"anonymous\" + count;\n            count += 1;\n\n        } while (document.getElementById(id));\n\n        element.id = id;\n\n    }\n\n    return id;\n\n};\n\n// Source: /src/instance/aria.js\n\n\n\n/**\n * Gets or sets WAI-ARIA properties. The properties will not be modified any\n * more than they need to be (unlike\n * [jQuery#ariaRef]{@link external:jQuery#ariaRef} or\n * [jQuery#ariaState]{@link external:jQuery#ariaState} which will interpret the\n * values).\n * <br><br>\n * To set WAI-ARIA properties, pass either a\n * <code>property</code>/<code>value</code> pair of arguments or an object\n * containing those pairs. When this is done, the attributes are set on all\n * elements in the collection and the <code>jQuery</code> object is returned to\n * allow for chaining. If <code>value</code> is a function and returns\n * <code>undefined</code> (or nothing) then no action is taken for that element.\n * This can be useful for selectively setting values only when certain criteria\n * are met.\n * <br><br>\n * To get WAI-ARIA properties, only pass the <code>property</code> that you want\n * to get. If there is no matching property, <code>undefined</code> is returned.\n * All properties are normalised (see\n * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria}).\n *\n * @memberof external:jQuery\n * @instance\n * @alias    aria\n * @param    {Object|String} property\n *           Either the properties to set in key/value pairs or the name of the\n *           property to get/set.\n * @param    {Attribute_Callback|Boolean|Number|String} [value]\n *           The value of the property to set.\n * @return   {jQuery|String|undefined}\n *           Either the jQuery object (after setting) or a string or undefined\n *           (after getting)\n *\n * @example <caption>Setting WAI-ARIA attribute(s)</caption>\n * $(\"#element\").aria(\"aria-label\", \"test\");\n * // or\n * $(\"#element\").aria(\"label\", \"test\");\n * // or\n * $(\"#element\").aria({\n *     \"aria-label\": \"test\"\n * });\n * // or\n * $(\"#element\").aria({\n *     label: \"test\"\n * });\n * // All of these set aria-label=\"test\" on all matching elements and return a\n * // jQuery object representing \"#element\"\n *\n * @example <caption>Setting WAI-ARIA attribute(s) with a function</caption>\n * $(\"#element\").aria(\"label\", function (i, attr) {\n *     return this.id + \"__\" + i + \"__\" + attr;\n * });\n * // or\n * $(\"#element\").aria({\n *     label: function (i, attr) {\n *         return this.id + \"__\" + i + \"__\" + attr;\n *     }\n * });\n * // Both of these set aria-label=\"element__0__undefined\" on all matching\n * // elements and return a jQuery object representing \"#element\"\n *\n * @example <caption>Getting a WAI-ARIA attribute</caption>\n * // Markup is:\n * // <div id=\"element\" aria-label=\"test\"></div>\n * $(\"#element\").aria(\"label\");   // -> \"test\"\n * $(\"#element\").aria(\"checked\"); // -> undefined\n * // If \"#element\" matches multiple elements, the attributes from the first\n * // element are returned.\n *\n * @example <caption>Setting with aria methods</caption>\n * // Markup is:\n * // <div class=\"one\"></div>\n * // <div class=\"two\"></div>\n * // <div class=\"three\"</div>\n *\n * var settings = {\n *     busy: 0,\n *     controls: \".one\",\n *     label: \"lorem ipsum\"\n * };\n *\n * $(\".one\").aria(settings);\n * $(\".two\").ariaRef(settings);\n * $(\".three\").ariaState(settings);\n *\n * // Now markup is:\n * // <div class=\"one\"\n * //     aria-busy=\"0\"\n * //     aria-controls=\".one\"\n * //     aria-label=\"lorem ipsum\"\n * //     id=\"anonymous0\"></div>\n * // <div class=\"two\"\n * //     aria-controls=\"anonymous0\"></div>\n * // <div class=\"three\"\n * //     aria-busy=\"false\"\n * //     aria-controls=\"true\"\n * //     aria-label=\"true\"></div>\n *\n * @example <caption>Getting with aria methods</caption>\n * // Markup is:\n * // <div id=\"test\" aria-flowto=\"false\"></div>\n * // <div id=\"false\"></div>\n *\n * $(\"#test\").aria(\"flowto\");      // -> \"false\"\n * $(\"#test\").ariaRef(\"flowto\");   // -> jQuery(<div id=\"false\">)\n * $(\"#test\").ariaState(\"flowto\"); // -> false\n */\n$.fn.aria = function (property, value) {\n\n    return access(\n        this,\n        property,\n        value\n    );\n\n};\n\n// Source: /src/instance/ariaRef.js\n\n\n\n/**\n * Gets or sets a WAI-ARIA reference. This is functionally identical to\n * [jQuery#aria]{@link external:jQuery#aria} with the main difference being that\n * an element may be passed as the <code>value</code> when setting and that a\n * jQuery object is returned when getting.\n * <br><br>\n * Because WAI-ARIA references work with IDs, IDs are worked out using\n * [jQuery#identify]{@link external:jQuery#identify}. Be aware that any string\n * passed to [jQuery#ariaRef]{@link external:jQuery#ariaRef} will be treated\n * like a CSS selector and looked up with the results being used to set the\n * property. If you already have the ID and wish to set it without the lookup,\n * use [jQuery#aria]{@link external:jQuery#aria}.\n * <br><br>\n * If <code>value</code> is a function then the resulting value is identified.\n * This can be particularly useful for performing DOM traversal to find the\n * reference (see examples below). As with\n * [jQuery#aria]{@link external:jQuery#aria}, if the <code>value</code> function\n * returns nothing or returns <code>undefined</code> then no action is taken.\n * <br><br>\n * When accessing the attribute using this function, a <code>jQuery</code>\n * object representing the reference is returned. If there are multiple elements\n * in the collection, only the reference for the first element is returned. To\n * get the value of the attribute rather than the element, use\n * [jQuery#aria]{@link external:jQuery#aria}.\n *\n * @memberof external:jQuery\n * @instance\n * @alias    ariaRef\n * @param    {Object|String} property\n *           Either the properties to set in key/value pairs or the name of the\n *           property to set.\n * @param    {Attribute_Callback|jQuery_param} [value]\n *           Reference to set.\n * @return   {jQuery}\n *           jQuery object representing either the elements that were modified\n *           (when setting) or the referenced element(s) (when getting - may be\n *           an empty jQuery object).\n *\n * @example <caption>Setting references</caption>\n * // Markup is:\n * // <h1>Heading</h1>\n * // <div class=\"one\">\n * //     Lorem ipsum dolor sit amet ...\n * // </div>\n *\n * $(\".one\").ariaRef(\"labelledby\", $(\"h1\"));\n * // or\n * $(\".one\").ariaRef(\"labelledby\", \"h1\");\n * // or\n * $(\".one\").ariaRef(\"labelledby\", $(\"h1\")[0]);\n * // or\n * $(\".one\").ariaRef({\n *     labelledby: $(\"h1\") // or \"h1\" or $(\"h1\")[0]\n * });\n * // Each of these return a jQuery object representing \".one\"\n *\n * // Now markup is:\n * // <h1 id=\"anonymous0\">Heading</h1>\n * // <div class=\"one\" aria-labelledby=\"anonymous0\">\n * //     Lorem ipsum dolor sit amet ...\n * // </div>\n *\n * @example <caption>Setting references with a function</caption>\n * // Markup is:\n * // <div class=\"js-collapse\">\n * //     <div class=\"js-collapse-content\">\n * //         Lorem ipsum dolor sit amet ...\n * //     </div>\n * //     <button class=\"js-collapse-toggle\">\n * //         Toggle\n * //     </button>\n * // </div>\n *\n * $(\".js-collapse-toggle\").ariaRef(\"controls\", function (i, attr) {\n *\n *     return $(this)\n *         .closest(\".js-collapse\")\n *         .find(\".js-collapse-content\");\n *\n * });\n *\n * // Now markup is:\n * // <div class=\"js-collapse\">\n * //     <div class=\"js-collapse-content\" id=\"anonymous0\">\n * //         Lorem ipsum dolor sit amet ...\n * //     </div>\n * //     <button class=\"js-collapse-toggle\" aria-controls=\"anonymous0\">\n * //         Toggle\n * //     </button>\n * // </div>\n *\n * @example <caption>Getting a reference</caption>\n * // Markup is:\n * // <h1 id=\"anonymous0\">Heading</h1>\n * // <div class=\"one\" aria-labelledby=\"anonymous0\">\n * //     Lorem ipsum dolor sit amet ...\n * // </div>\n *\n * $(\".one\").ariaRef(\"labelledby\"); // -> $(<h1>)\n * $(\".one\").ariaRef(\"controls\");   // -> $()\n *\n * @example <caption>Value is treated like a CSS selector</caption>\n * // Markup is:\n * // <button id=\"button\"></button>\n * // <div id=\"section\"></div>\n * // <section></section>\n *\n * $(\"#button\").ariaRef(\"controls\", \"section\");\n *\n * // Now markup is:\n * // <button id=\"button\" aria-controls=\"anonymous0\"></button>\n * // <div id=\"section\"></div>\n * // <section id=\"anonymous0\"></section>\n */\n$.fn.ariaRef = function (property, value) {\n\n    return access(\n        this,\n        property,\n        value,\n        HANDLER_REFERENCE\n    );\n\n};\n\n// Source: /src/instance/ariaState.js\n\n\n\n/**\n * Sets or gets the WAI-ARIA state of the collection.\n * <br><br>\n * When setting the state, false, \"false\" (any case), 0 and \"0\" will be\n * considered false. All other values will be considered true except for \"mixed\"\n * (any case) which will set the state to \"mixed\". The differs from\n * [jQuery#aria]{@link external:jQuery#aria} which will simply set the\n * attribute(s) without converting the value.\n * <br><br>\n * After setting the state(s), a jQuery object representing the affected\n * elements is returned. The state for the first matching element is returned\n * when getting.\n * <br><br>\n * All attributes are normalised - see\n * [jQuery.normaliseAria]{@link external:jQuery.normaliseAria} for full details.\n *\n * @memberof external:jQuery\n * @instance\n * @alias    ariaState\n * @param    {Object|String} property\n *           Either a key/value combination properties to set or the name of the\n *           WAI-ARIA state to set.\n * @param    {Attribute_Callback|Boolean|Number|String} [value]\n *           Value of the attribute.\n * @return   {ARIA_state|jQuery}\n *           Either the jQuery object representing the modified elements\n *           (setting) or the state of the first matching element.\n *\n * @example <caption>Getting state</caption>\n * // Markup is:\n * // <div id=\"one\" aria-busy=\"true\" aria-checked=\"mixed\"></div>\n *\n * $(\"#one\").ariaState(\"busy\");    // -> true\n * $(\"#one\").ariaState(\"checked\"); // -> \"mixed\"\n * $(\"#one\").ariaState(\"hidden\");  // -> undefined\n *\n * @example <caption>Setting state</caption>\n * // Each of these will set the state to false:\n * $(\"#one\").ariaState(\"busy\", \"false\");\n * $(\"#one\").ariaState(\"busy\", \"FALSE\");\n * $(\"#one\").ariaState(\"busy\", false);\n * $(\"#one\").ariaState(\"busy\", 0);\n * $(\"#one\").ariaState(\"busy\", \"0\");\n *\n * // Each of these will set the state to \"mixed\":\n * $(\"#one\").ariaState(\"checked\", \"mixed\");\n * $(\"#one\").ariaState(\"checked\", \"MIXED\");\n *\n * // Each of these will set the state to true\n * $(\"#one\").ariaState(\"busy\", \"true\");\n * $(\"#one\").ariaState(\"busy\", \"TRUE\");\n * $(\"#one\").ariaState(\"busy\", true);\n * $(\"#one\").ariaState(\"busy\", 1);\n * $(\"#one\").ariaState(\"busy\", \"1\");\n * // WARNING: these also set the state to true\n * $(\"#one\").ariaState(\"busy\", {});\n * $(\"#one\").ariaState(\"busy\", null);\n * $(\"#one\").ariaState(\"busy\", \"nothing\");\n * $(\"#one\").ariaState(\"busy\", \"\");\n * $(\"#one\").ariaState(\"busy\", -1);\n *\n * // Each example returns a jQuery object representing \"#one\" and an object\n * // can be passed as parameters as well:\n * $(\"#one\").ariaState({\n *     busy: true\n * });\n *\n * @example <caption>Setting state with a function</caption>\n * // Markup is:\n * // <div class=\"checkbox\"></div>\n * // <input type=\"checkbox\" checked>\n *\n * $(\".checkbox\").ariaState(\"checked\", function (i, attr) {\n *\n *     return $(this)\n *         .next(\"input[type=\\\"checkbox\\\"]\")\n *         .prop(\"checked\");\n *\n * });\n *\n * // Now markup is:\n * // <div class=\"checkbox\" aria-checked=\"true\"></div>\n * // <input type=\"checkbox\" checked>\n */\n$.fn.ariaState = function (property, value) {\n\n    return access(\n        this,\n        property,\n        value,\n        HANDLER_STATE\n    );\n\n};\n\n// Source: /src/instance/removeAria.js\n\n\n$.fn.extend({\n\n    removeAria: removeAttribute,\n\n    /**\n     * Alias of [jQuery#removeAria]{@link external:jQuery#removeAria}.\n     *\n     * @memberof external:jQuery\n     * @instance\n     * @function\n     * @param    {String} name\n     *           WAI-ARIA attribute to remove.\n     * @return   {jQuery}\n     *           jQuery attribute representing the elements modified.\n     */\n    removeAriaRef: removeAttribute,\n\n    /**\n     * Alias of [jQuery#removeAria]{@link external:jQuery#removeAria}.\n     *\n     * @memberof external:jQuery\n     * @instance\n     * @function\n     * @param    {String} name\n     *           WAI-ARIA attribute to remove.\n     * @return   {jQuery}\n     *           jQuery attribute representing the elements modified.\n     */\n    removeAriaState: removeAttribute\n\n});\n\n// Source: /src/instance/role.js\n\n\n\n/**\n * Sets the role of all elements in the collection or gets the role of the first\n * element in the collection, depending on whether or not the <code>role</code>\n * argument is provided. As [jQuery#role]{@link external:jQuery#role} is just a\n * wrapper for [jQuery#attr]{@link http://api.jquery.com/attr/}, the\n * <code>role</code> parameter can actually be any value type that the official\n * documentation mentions.\n * <br><br>\n * According to the WAI-ARIA specs, an element can have mutliple roles as a\n * space-separated list. This method will only set the role attribute to the\n * given string when setting. If you want to modify the roles, use\n * [jQuery#addRole]{@link external:jQuery#addRole} and\n * [jQuery#removeRole]{@link external:jQuery#removeRole}.\n *\n * @memberof external:jQuery\n * @instance\n * @alias    role\n * @param    {Attribute_Callback|String} [role]\n *           Role to get or function to set the role.\n * @return   {jQuery|String|undefined}\n *           Either the jQuery object representing the elements that were\n *           modified or the role value.\n *\n * @example\n * // Markup is:\n * // <div id=\"one\"></div>\n * // <div id=\"two\"></div>\n *\n * $(\"#one\").role(\"presentation\"); // -> jQuery(<div id=\"one\">)\n *\n * // Now markup is:\n * // <div id=\"one\" role=\"presentation\"></div>\n * // <div id=\"two\"></div>\n *\n * $(\"#one\").role(); // -> \"presentation\"\n * $(\"#two\").role(); // -> undefined\n *\n * @example <caption>Setting a role with a function</caption>\n * // Markup is:\n * // <div id=\"one\" role=\"button\"></div>\n *\n * $(\"#one\").role(function (index, current) {\n *     return current + \" tooltip\";\n * });\n *\n * // Now markup is:\n * // <div id=\"one\" role=\"button tooltip\"></div>\n */\n$.fn.role = function (role) {\n\n    return role === undefined\n        ? this.attr(\"role\")\n        : this.attr(\"role\", role);\n\n};\n\n// Source: /src/instance/addRole.js\n\n\n\n/**\n * Adds a role to a collection of elements. The role will not be added if it's\n * empty (\"\" or undefined), if the function response is empty or if the element\n * already has that role. In that way it's similar to\n * [jQuery#addClass]{@link https://api.jquery.com/addClass/}.\n *\n * @memberof external:jQuery\n * @instance\n * @alias    addRole\n * @param    {Attribute_Callback|String} role\n *           Role(s) to add to the matching elements or function to generate the\n *           role(s) to add.\n * @return   {jQuery}\n *           jQuery object representing the matching elements.\n *\n * @example <caption>Adding a role</caption>\n * // Markup is:\n * // <div class=\"one\" role=\"presentation\"></div>\n * // <div class=\"one\"></div>\n *\n * $(\".one\").addRole(\"alert\"); // -> jQuery(<div>, <div>)\n *\n * // Now markup is:\n * // <div class=\"one\" role=\"presentation alert\"></div>\n * // <div class=\"one\" role=\"alert\"></div>\n *\n * @example <caption>Adding a role with a function</caption>\n * // Markup is:\n * // <div class=\"one\" role=\"presentation\"></div>\n *\n * $(\".one\").addRole(function (index, current) {\n *     return \"alert combobox\";\n * });\n *\n * // Now markup is:\n * // <div class=\"one\" role=\"presentation alert combobox\"></div>\n */\n$.fn.addRole = function (role) {\n\n    var isFunction = $.isFunction(role);\n\n    return this.role(function (index, current) {\n\n        var value = isFunction\n            ? role.call(this, index, current)\n            : role;\n        var roles = toWords(current);\n\n        toWords(value).forEach(function (val) {\n\n            if (\n                val !== \"\"\n                && val !== undefined\n                && roles.indexOf(val) < 0\n            ) {\n                roles.push(val);\n            }\n\n        });\n\n        return roles.join(\" \");\n\n    });\n\n};\n\n// Source: /src/instance/removeRole.js\n\n\n\n/**\n * Removes roles from the collection of elements. If the method is called\n * without any arguments then the role attribute itself is removed. Be aware\n * that this is not the same as passing a function which returns undefined -\n * such an action will have no effect.\n *\n * @memberof external:jQuery\n * @instance\n * @alias    removeRole\n * @param    {Attribute_Callback|String} [role]\n *           Role(s) to remove or a function to generate the role(s) to remove.\n * @return   {jQuery}\n *           jQuery object representing the matched elements.\n *\n * @example <caption>Removing a role</caption>\n * // Markup is:\n * // <div class=\"one\" role=\"presentation alert\"></div>\n * // <div class=\"one\" role=\"alert\"></div>\n *\n * $(\".one\").removeRole(\"alert\"); // -> jQuery(<div>, <div>)\n *\n * // Now markup is:\n * // <div class=\"one\" role=\"presentation\"></div>\n * // <div class=\"one\" role=\"\"></div>\n *\n * @example <caption>Completely removing a role</caption>\n * // Markup is:\n * // <div class=\"one\" role=\"presentation alert\"></div>\n * // <div class=\"one\" role=\"alert\"></div>\n *\n * $(\".one\").removeRole(); // -> jQuery(<div>, <div>)\n *\n * // Now markup is:\n * // <div class=\"one\"></div>\n * // <div class=\"one\"></div>\n *\n * @example <caption>Removing a role with a function</caption>\n * // Markup is:\n * // <div class=\"one\" role=\"presentation alert combobox\"></div>\n *\n * $(\".one\").removeRole(function (index, current) {\n *     return current\n *         .split(/\\s+/)\n *         .filter(function (role) {\n *             return role.indexOf(\"a\") > -1;\n *         })\n *         .join(\" \");\n *     // \"presentation alert\"\n * });\n *\n * // Now markup is:\n * // <div class=\"one\" role=\"combobox\"></div>\n */\n$.fn.removeRole = function (role) {\n\n    var isFunction = $.isFunction(role);\n\n    return role === undefined\n        ? this.removeAttr(\"role\")\n        : this.role(function (index, current) {\n\n            var value = isFunction\n                ? role.call(this, index, current)\n                : role;\n            var values = toWords(value);\n\n            return toWords(current)\n                .filter(function (aRole) {\n                    return values.indexOf(aRole) < 0;\n                })\n                .join(\" \");\n\n        });\n\n};\n\n// Source: /src/instance/ariaFocusable.js\n\n\n\n/**\n * Sets whether or not the matching elements are focusable. Strings, numbers and\n * booleans are understood as <code>state</code> - see\n * [jQuery#ariaState]{@link external:jQuery#ariaState} for full details as the\n * algorythm is the same.\n * <br><br>\n * Be aware this this function will only modify the matching elements, it will\n * not check any parents or modify any other elements that could affect the\n * focusability of the element.\n *\n * @memberof external:jQuery\n * @instance\n * @alias    ariaFocusable\n * @param    {Attribute_Callback|Boolean|Number|String} state\n *           State to set.\n * @return   {jQuery}\n *           jQuery object representing the affected element(s).\n *\n * @example <caption>Setting focusability</caption>\n * // Markup is\n * // <div id=\"one\"></div>\n * // <div id=\"two\"></div>\n *\n * $(\"#one\").ariaFocusable(false); // -> jQuery(<div id=\"one\">)\n * $(\"#two\").ariaFocusable(true);  // -> jQuery(<div id=\"two\">)\n *\n * // Now markup is\n * // <div id=\"one\" tabindex=\"0\"></div>\n * // <div id=\"two\" tabindex=\"-1\"></div>\n *\n * @example <caption>Limitations of the function</caption>\n * // Markup is\n * // <div id=\"one\" tabindex=\"-1\">\n * //     <div id=\"two\" disabled></div>\n * // </div>\n *\n * $(\"#two\").ariaFocusable(true); // -> jQuery(<div id=\"two\">)\n *\n * // Now markup is\n * // <div id=\"one\" tabindex=\"-1\">\n * //     <div id=\"two\" disabled tabindex=\"0\"></div>\n * // </div>\n */\n$.fn.ariaFocusable = function (state) {\n\n    return this.attr(\n        \"tabindex\",\n        handlers[HANDLER_STATE].read(state)\n            ? 0\n            : -1\n    );\n\n};\n\n}(jQuery));"],"file":"jquery.aria.js"}